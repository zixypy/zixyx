local Players = game:GetService('Players')
local Workspace = game:GetService('Workspace')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')

local ZixyESP = {}
ZixyESP.__index = ZixyESP

-- Configuration
ZixyESP.Config = {
    TeamCheck = true,
    ESPDistance = 325,
    BoxColor = Color3.new(0.403922, 0.349020, 0.701961),
    SkeletonColor = Color3.new(0.403922, 0.349020, 0.701961),
    ChamsColor = Color3.new(1, 0, 0),
    TracerOrigin = 'Bottom Screen',
    TracerColor = Color3.new(0.403922, 0.349020, 0.701961),
}

-- State
ZixyESP.State = {
    BoxEnabled = false,
    NameEnabled = false,
    DistanceEnabled = false,
    SkeletonEnabled = false,
    HealthTextEnabled = false,
    HealthBarEnabled = false,
    TracerEnabled = false,
    ChamsEnabled = false,
}

-- Cache
ZixyESP.Caches = {
    BoxCache = {},
    SkeletonCache = {},
    HealthCache = {},
    TracerCache = {},
    ChamsCache = {},
}

-- Internal variables
local LocalPlayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera
local cleanupInterval = 30 -- Cleanup every 30 seconds
local cleanupConnection
local updateConnection

-- Utility function for safe execution
local function SafeExecute(func)
    local success, errorMessage = pcall(func)
    if not success then
        warn("ZixyESP Error: " .. tostring(errorMessage))
    end
end

-- Create ESP elements
function ZixyESP:CreateBox(player)
    local esp = {
        Box = Drawing.new('Square'),
        Name = Drawing.new('Text'),
        Distance = Drawing.new('Text'),
        HealthText = Drawing.new('Text'),
        HealthBarBackground = Drawing.new('Square'),
        HealthBar = Drawing.new('Square'),
    }

    esp.Box.Thickness = 2
    esp.Box.Color = self.Config.BoxColor
    esp.Box.Filled = false
    esp.Box.Visible = false

    esp.Name.Size = 16
    esp.Name.Color = Color3.new(1, 1, 1)
    esp.Name.Outline = true
    esp.Name.Center = true
    esp.Name.Visible = false

    esp.Distance.Size = 16
    esp.Distance.Color = Color3.new(1, 1, 1)
    esp.Distance.Outline = true
    esp.Distance.Center = true
    esp.Distance.Visible = false

    esp.HealthText.Size = 16
    esp.HealthText.Color = Color3.new(1, 1, 1)
    esp.HealthText.Outline = true
    esp.HealthText.Center = true
    esp.HealthText.Visible = false

    esp.HealthBarBackground.Size = Vector2.new(5, 50)
    esp.HealthBarBackground.Color = Color3.new(0, 0, 0)
    esp.HealthBarBackground.Filled = true
    esp.HealthBarBackground.Transparency = 0.5
    esp.HealthBarBackground.Visible = false

    esp.HealthBar.Size = Vector2.new(5, 50)
    esp.HealthBar.Color = Color3.new(0, 1, 0)
    esp.HealthBar.Filled = true
    esp.HealthBar.Visible = false

    return esp
end

function ZixyESP:CreateSkeleton(player)
    local skeleton = {
        HeadToNeck = Drawing.new('Line'),
        NeckToUpperTorso = Drawing.new('Line'),
        UpperTorsoToLowerTorso = Drawing.new('Line'),
        UpperTorsoToLeftUpperArm = Drawing.new('Line'),
        LeftUpperArmToLeftLowerArm = Drawing.new('Line'),
        LeftLowerArmToLeftHand = Drawing.new('Line'),
        UpperTorsoToRightUpperArm = Drawing.new('Line'),
        RightUpperArmToRightLowerArm = Drawing.new('Line'),
        RightLowerArmToRightHand = Drawing.new('Line'),
        LowerTorsoToLeftUpperLeg = Drawing.new('Line'),
        LeftUpperLegToLeftLowerLeg = Drawing.new('Line'),
        LeftLowerLegToLeftFoot = Drawing.new('Line'),
        LowerTorsoToRightUpperLeg = Drawing.new('Line'),
        RightUpperLegToRightLowerLeg = Drawing.new('Line'),
        RightLowerLegToRightFoot = Drawing.new('Line'),
    }

    for _, line in pairs(skeleton) do
        line.Thickness = 2
        line.Color = self.Config.SkeletonColor
        line.Visible = false
    end

    return skeleton
end

function ZixyESP:CreateTracer(player)
    local tracer = Drawing.new('Line')
    tracer.Thickness = 2
    tracer.Color = self.Config.TracerColor
    tracer.Visible = false
    return tracer
end

function ZixyESP:CreateChams(player)
    local highlight = Instance.new("Highlight")
    highlight.FillColor = self.Config.ChamsColor
    highlight.OutlineColor = Color3.new(1, 1, 1)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = player.Character
    highlight.Adornee = player.Character
    return highlight
end

-- Clear ESP elements
function ZixyESP:ClearBox(player)
    if self.Caches.BoxCache[player] then
        self.Caches.BoxCache[player].Box:Remove()
        self.Caches.BoxCache[player].Name:Remove()
        self.Caches.BoxCache[player].Distance:Remove()
        self.Caches.BoxCache[player].HealthText:Remove()
        self.Caches.BoxCache[player].HealthBarBackground:Remove()
        self.Caches.BoxCache[player].HealthBar:Remove()
        self.Caches.BoxCache[player] = nil
    end
end

function ZixyESP:ClearSkeleton(player)
    if self.Caches.SkeletonCache[player] then
        for _, line in pairs(self.Caches.SkeletonCache[player]) do
            line:Remove()
        end
        self.Caches.SkeletonCache[player] = nil
    end
end

function ZixyESP:ClearTracer(player)
    if self.Caches.TracerCache[player] then
        self.Caches.TracerCache[player]:Remove()
        self.Caches.TracerCache[player] = nil
    end
end

function ZixyESP:ClearChams(player)
    if self.Caches.ChamsCache[player] then
        self.Caches.ChamsCache[player]:Destroy()
        self.Caches.ChamsCache[player] = nil
    end
end

-- Update ESP elements
function ZixyESP:UpdateBox()
    if not (self.State.BoxEnabled or self.State.NameEnabled or self.State.DistanceEnabled or self.State.HealthTextEnabled or self.State.HealthBarEnabled) then
        for player, _ in pairs(self.Caches.BoxCache) do
            self:ClearBox(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(self.Caches.BoxCache) do
            self:ClearBox(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            self:ClearBox(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            self:ClearBox(player)
            continue
        end

        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > self.Config.ESPDistance then
            self:ClearBox(player)
            continue
        end

        if self.Config.TeamCheck and LocalPlayer.Team and player.Team == LocalPlayer.Team then
            self:ClearBox(player)
            continue
        end

        if not self.Caches.BoxCache[player] then
            self.Caches.BoxCache[player] = self:CreateBox(player)
        end

        local esp = self.Caches.BoxCache[player]
        local rootPos, onScreen = camera:WorldToViewportPoint(targetRoot.Position)
        if onScreen then
            local head = character:FindFirstChild("Head")
            local topPos = head and camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1, 0)) or camera:WorldToViewportPoint(targetRoot.Position + Vector3.new(0, 3, 0))
            local bottomPos = camera:WorldToViewportPoint(targetRoot.Position - Vector3.new(0, 3, 0))
            local height = math.abs(topPos.Y - bottomPos.Y)
            local width = height * 0.7 -- Increased width multiplier from 0.5 to 0.7
            local centerPos = Vector2.new(rootPos.X, (topPos.Y + bottomPos.Y) / 2)
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = centerPos - Vector2.new(width / 2, height / 2)
            esp.Box.Visible = self.State.BoxEnabled

            esp.Name.Text = player.Name
            esp.Name.Position = Vector2.new(rootPos.X, topPos.Y - 20)
            esp.Name.Visible = self.State.NameEnabled

            esp.Distance.Text = tostring(math.floor(distance)) .. " studs"
            esp.Distance.Position = Vector2.new(rootPos.X, bottomPos.Y + 5)
            esp.Distance.Visible = self.State.DistanceEnabled

            -- Health Text ESP
            if self.State.HealthTextEnabled then
                local healthPercentage = humanoid.Health / humanoid.MaxHealth
                esp.HealthText.Text = "Health: " .. tostring(math.floor(healthPercentage * 100)) .. "%"
                esp.HealthText.Position = Vector2.new(rootPos.X, topPos.Y - 40) -- Above Name ESP
                esp.HealthText.Visible = true
            else
                esp.HealthText.Visible = false
            end

            -- Health Bar ESP
            if self.State.HealthBarEnabled then
                local healthPercentage = humanoid.Health / humanoid.MaxHealth
                local barHeight = height
                local barWidth = 5
                local barPosX = centerPos.X - (width / 2) - 10 -- To the left of the left line of the box
                local barPosY = centerPos.Y - (height / 2)
                esp.HealthBarBackground.Position = Vector2.new(barPosX, barPosY)
                esp.HealthBarBackground.Size = Vector2.new(barWidth, barHeight)
                esp.HealthBarBackground.Visible = true
                esp.HealthBar.Position = Vector2.new(barPosX, barPosY + (barHeight * (1 - healthPercentage)))
                esp.HealthBar.Size = Vector2.new(barWidth, barHeight * healthPercentage)
                esp.HealthBar.Color = Color3.new(1 - healthPercentage, healthPercentage, 0)
                esp.HealthBar.Visible = true
            else
                esp.HealthBarBackground.Visible = false
                esp.HealthBar.Visible = false
            end
        else
            esp.Box.Visible = false
            esp.Name.Visible = false
            esp.Distance.Visible = false
            esp.HealthText.Visible = false
            esp.HealthBarBackground.Visible = false
            esp.HealthBar.Visible = false
        end
    end
end

function ZixyESP:UpdateSkeleton()
    if not self.State.SkeletonEnabled then
        for player, _ in pairs(self.Caches.SkeletonCache) do
            self:ClearSkeleton(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(self.Caches.SkeletonCache) do
            self:ClearSkeleton(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            self:ClearSkeleton(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            self:ClearSkeleton(player)
            continue
        end

        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > self.Config.ESPDistance then
            self:ClearSkeleton(player)
            continue
        end

        if self.Config.TeamCheck and LocalPlayer.Team and player.Team == LocalPlayer.Team then
            self:ClearSkeleton(player)
            continue
        end

        if not self.Caches.SkeletonCache[player] then
            self.Caches.SkeletonCache[player] = self:CreateSkeleton(player)
        end

        local skeleton = self.Caches.SkeletonCache[player]
        local rigType = humanoid.RigType
        local parts = {}

        -- Determine parts based on rig type
        if rigType == Enum.HumanoidRigType.R15 then
            parts = {
                Head = character:FindFirstChild("Head"),
                Neck = character:FindFirstChild("Neck") or character:FindFirstChild("Head"),
                UpperTorso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"),
                LowerTorso = character:FindFirstChild("LowerTorso") or character:FindFirstChild("HumanoidRootPart"),
                LeftUpperArm = character:FindFirstChild("LeftUpperArm"),
                LeftLowerArm = character:FindFirstChild("LeftLowerArm"),
                LeftHand = character:FindFirstChild("LeftHand"),
                RightUpperArm = character:FindFirstChild("RightUpperArm"),
                RightLowerArm = character:FindFirstChild("RightLowerArm"),
                RightHand = character:FindFirstChild("RightHand"),
                LeftUpperLeg = character:FindFirstChild("LeftUpperLeg"),
                LeftLowerLeg = character:FindFirstChild("LeftLowerLeg"),
                LeftFoot = character:FindFirstChild("LeftFoot"),
                RightUpperLeg = character:FindFirstChild("RightUpperLeg"),
                RightLowerLeg = character:FindFirstChild("RightLowerLeg"),
                RightFoot = character:FindFirstChild("RightFoot"),
            }
        elseif rigType == Enum.HumanoidRigType.R6 then
            parts = {
                Head = character:FindFirstChild("Head"),
                Neck = character:FindFirstChild("Head"), -- No distinct neck in R6
                UpperTorso = character:FindFirstChild("Torso"),
                LowerTorso = character:FindFirstChild("Torso"), -- No distinct lower torso in R6
                LeftUpperArm = character:FindFirstChild("LeftArm"),
                LeftLowerArm = character:FindFirstChild("LeftArm"), -- No distinct lower arm in R6
                LeftHand = character:FindFirstChild("LeftArm"), -- Hand approximated by arm
                RightUpperArm = character:FindFirstChild("RightArm"),
                RightLowerArm = character:FindFirstChild("RightArm"), -- No distinct lower arm in R6
                RightHand = character:FindFirstChild("RightArm"), -- Hand approximated by arm
                LeftUpperLeg = character:FindFirstChild("LeftLeg"),
                LeftLowerLeg = character:FindFirstChild("LeftLeg"), -- No distinct lower leg in R6
                LeftFoot = character:FindFirstChild("LeftLeg"), -- Foot approximated by leg
                RightUpperLeg = character:FindFirstChild("RightLeg"),
                RightLowerLeg = character:FindFirstChild("RightLeg"), -- No distinct lower leg in R6
                RightFoot = character:FindFirstChild("RightLeg"), -- Foot approximated by leg
            }
        else
            self:ClearSkeleton(player)
            continue
        end

        -- Ensure at least core parts are present
        if not (parts.Head and parts.UpperTorso and parts.LowerTorso) then
            self:ClearSkeleton(player)
            continue
        end

        -- Get viewport points with nil checks
        local headPos, headOnScreen = parts.Head and camera:WorldToViewportPoint(parts.Head.Position) or nil
        local neckPos, neckOnScreen = parts.Neck and camera:WorldToViewportPoint(parts.Neck.Position) or headPos
        local upperTorsoPos, upperTorsoOnScreen = parts.UpperTorso and camera:WorldToViewportPoint(parts.UpperTorso.Position) or nil
        local lowerTorsoPos, lowerTorsoOnScreen = parts.LowerTorso and camera:WorldToViewportPoint(parts.LowerTorso.Position) or upperTorsoPos
        local leftUpperArmPos, leftUpperArmOnScreen = parts.LeftUpperArm and camera:WorldToViewportPoint(parts.LeftUpperArm.Position) or nil
        local leftLowerArmPos, leftLowerArmOnScreen = parts.LeftLowerArm and camera:WorldToViewportPoint(parts.LeftLowerArm.Position) or leftUpperArmPos
        local leftHandPos, leftHandOnScreen = parts.LeftHand and camera:WorldToViewportPoint(parts.LeftHand.Position) or leftLowerArmPos
        local rightUpperArmPos, rightUpperArmOnScreen = parts.RightUpperArm and camera:WorldToViewportPoint(parts.RightUpperArm.Position) or nil
        local rightLowerArmPos, rightLowerArmOnScreen = parts.RightLowerArm and camera:WorldToViewportPoint(parts.RightLowerArm.Position) or rightUpperArmPos
        local rightHandPos, rightHandOnScreen = parts.RightHand and camera:WorldToViewportPoint(parts.RightHand.Position) or rightLowerArmPos
        local leftUpperLegPos, leftUpperLegOnScreen = parts.LeftUpperLeg and camera:WorldToViewportPoint(parts.LeftUpperLeg.Position) or nil
        local leftLowerLegPos, leftLowerLegOnScreen = parts.LeftLowerArm and camera:WorldToViewportPoint(parts.LeftLowerLeg.Position) or leftUpperLegPos
        local leftFootPos, leftFootOnScreen = parts.LeftFoot and camera:WorldToViewportPoint(parts.LeftFoot.Position) or leftLowerLegPos
        local rightUpperLegPos, rightUpperLegOnScreen = parts.RightUpperLeg and camera:WorldToViewportPoint(parts.RightUpperLeg.Position) or nil
        local rightLowerLegPos, rightLowerLegOnScreen = parts.RightLowerLeg and camera:WorldToViewportPoint(parts.RightLowerLeg.Position) or rightUpperLegPos
        local rightFootPos, rightFootOnScreen = parts.RightFoot and camera:WorldToViewportPoint(parts.RightFoot.Position) or rightLowerLegPos

        -- Draw skeleton lines with nil checks
        if headPos and neckPos and headOnScreen and neckOnScreen then
            skeleton.HeadToNeck.From = Vector2.new(headPos.X, headPos.Y)
            skeleton.HeadToNeck.To = Vector2.new(neckPos.X, neckPos.Y)
            skeleton.HeadToNeck.Visible = self.State.SkeletonEnabled
        else
            skeleton.HeadToNeck.Visible = false
        end

        if neckPos and upperTorsoPos and neckOnScreen and upperTorsoOnScreen then
            skeleton.NeckToUpperTorso.From = Vector2.new(neckPos.X, neckPos.Y)
            skeleton.NeckToUpperTorso.To = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.NeckToUpperTorso.Visible = self.State.SkeletonEnabled
        else
            skeleton.NeckToUpperTorso.Visible = false
        end

        if upperTorsoPos and lowerTorsoPos and upperTorsoOnScreen and lowerTorsoOnScreen then
            skeleton.UpperTorsoToLowerTorso.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToLowerTorso.To = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.UpperTorsoToLowerTorso.Visible = self.State.SkeletonEnabled
        else
            skeleton.UpperTorsoToLowerTorso.Visible = false
        end

        if upperTorsoPos and leftUpperArmPos and upperTorsoOnScreen and leftUpperArmOnScreen then
            skeleton.UpperTorsoToLeftUpperArm.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToLeftUpperArm.To = Vector2.new(leftUpperArmPos.X, leftUpperArmPos.Y)
            skeleton.UpperTorsoToLeftUpperArm.Visible = self.State.SkeletonEnabled
        else
            skeleton.UpperTorsoToLeftUpperArm.Visible = false
        end

        if leftUpperArmPos and leftLowerArmPos and leftUpperArmOnScreen and leftLowerArmOnScreen then
            skeleton.LeftUpperArmToLeftLowerArm.From = Vector2.new(leftUpperArmPos.X, leftUpperArmPos.Y)
            skeleton.LeftUpperArmToLeftLowerArm.To = Vector2.new(leftLowerArmPos.X, leftLowerArmPos.Y)
            skeleton.LeftUpperArmToLeftLowerArm.Visible = self.State.SkeletonEnabled
        else
            skeleton.LeftUpperArmToLeftLowerArm.Visible = false
        end

        if leftLowerArmPos and leftHandPos and leftLowerArmOnScreen and leftHandOnScreen then
            skeleton.LeftLowerArmToLeftHand.From = Vector2.new(leftLowerArmPos.X, leftLowerArmPos.Y)
            skeleton.LeftLowerArmToLeftHand.To = Vector2.new(leftHandPos.X, leftHandPos.Y)
            skeleton.LeftLowerArmToLeftHand.Visible = self.State.SkeletonEnabled
        else
            skeleton.LeftLowerArmToLeftHand.Visible = false
        end

        if upperTorsoPos and rightUpperArmPos and upperTorsoOnScreen and rightUpperArmOnScreen then
            skeleton.UpperTorsoToRightUpperArm.From = Vector2.new(upperTorsoPos.X, upperTorsoPos.Y)
            skeleton.UpperTorsoToRightUpperArm.To = Vector2.new(rightUpperArmPos.X, rightUpperArmPos.Y)
            skeleton.UpperTorsoToRightUpperArm.Visible = self.State.SkeletonEnabled
        else
            skeleton.UpperTorsoToRightUpperArm.Visible = false
        end

        if rightUpperArmPos and rightLowerArmPos and rightUpperArmOnScreen and rightLowerArmOnScreen then
            skeleton.RightUpperArmToRightLowerArm.From = Vector2.new(rightUpperArmPos.X, rightUpperArmPos.Y)
            skeleton.RightUpperArmToRightLowerArm.To = Vector2.new(rightLowerArmPos.X, rightLowerArmPos.Y)
            skeleton.RightUpperArmToRightLowerArm.Visible = self.State.SkeletonEnabled
        else
            skeleton.RightUpperArmToRightLowerArm.Visible = false
        end

        if rightLowerArmPos and rightHandPos and rightLowerArmOnScreen and rightHandOnScreen then
            skeleton.RightLowerArmToRightHand.From = Vector2.new(rightLowerArmPos.X, rightLowerArmPos.Y)
            skeleton.RightLowerArmToRightHand.To = Vector2.new(rightHandPos.X, rightHandPos.Y)
            skeleton.RightLowerArmToRightHand.Visible = self.State.SkeletonEnabled
        else
            skeleton.RightLowerArmToRightHand.Visible = false
        end

        if lowerTorsoPos and leftUpperLegPos and lowerTorsoOnScreen and leftUpperLegOnScreen then
            skeleton.LowerTorsoToLeftUpperLeg.From = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.LowerTorsoToLeftUpperLeg.To = Vector2.new(leftUpperLegPos.X, leftUpperLegPos.Y)
            skeleton.LowerTorsoToLeftUpperLeg.Visible = self.State.SkeletonEnabled
        else
            skeleton.LowerTorsoToLeftUpperLeg.Visible = false
        end

        if leftUpperLegPos and leftLowerLegPos and leftUpperLegOnScreen and leftLowerLegOnScreen then
            skeleton.LeftUpperLegToLeftLowerLeg.From = Vector2.new(leftUpperLegPos.X, leftUpperLegPos.Y)
            skeleton.LeftUpperLegToLeftLowerLeg.To = Vector2.new(leftLowerLegPos.X, leftLowerLegPos.Y)
            skeleton.LeftUpperLegToLeftLowerLeg.Visible = self.State.SkeletonEnabled
        else
            skeleton.LeftUpperLegToLeftLowerLeg.Visible = false
        end

        if leftLowerLegPos and leftFootPos and leftLowerLegOnScreen and leftFootOnScreen then
            skeleton.LeftLowerLegToLeftFoot.From = Vector2.new(leftLowerLegPos.X, leftLowerLegPos.Y)
            skeleton.LeftLowerLegToLeftFoot.To = Vector2.new(leftFootPos.X, leftFootPos.Y)
            skeleton.LeftLowerLegToLeftFoot.Visible = self.State.SkeletonEnabled
        else
            skeleton.LeftLowerLegToLeftFoot.Visible = false
        end

        if lowerTorsoPos and rightUpperLegPos and lowerTorsoOnScreen and rightUpperLegOnScreen then
            skeleton.LowerTorsoToRightUpperLeg.From = Vector2.new(lowerTorsoPos.X, lowerTorsoPos.Y)
            skeleton.LowerTorsoToRightUpperLeg.To = Vector2.new(rightUpperLegPos.X, rightUpperLegPos.Y)
            skeleton.LowerTorsoToRightUpperLeg.Visible = self.State.SkeletonEnabled
        else
            skeleton.LowerTorsoToRightUpperLeg.Visible = false
        end

        if rightUpperLegPos and rightLowerLegPos and rightUpperLegOnScreen and rightLowerLegOnScreen then
            skeleton.RightUpperLegToRightLowerLeg.From = Vector2.new(rightUpperLegPos.X, rightUpperLegPos.Y)
            skeleton.RightUpperLegToRightLowerLeg.To = Vector2.new(rightLowerLegPos.X, rightLowerLegPos.Y)
            skeleton.RightUpperLegToRightLowerLeg.Visible = self.State.SkeletonEnabled
        else
            skeleton.RightUpperLegToRightLowerLeg.Visible = false
        end

        if rightLowerLegPos and rightFootPos and rightLowerLegOnScreen and rightFootOnScreen then
            skeleton.RightLowerLegToRightFoot.From = Vector2.new(rightLowerLegPos.X, rightLowerLegPos.Y)
            skeleton.RightLowerLegToRightFoot.To = Vector2.new(rightFootPos.X, rightFootPos.Y)
            skeleton.RightLowerLegToRightFoot.Visible = self.State.SkeletonEnabled
        else
            skeleton.RightLowerLegToRightFoot.Visible = false
        end
    end
end

function ZixyESP:UpdateTracer()
    if not self.State.TracerEnabled then
        for player, _ in pairs(self.Caches.TracerCache) do
            self:ClearTracer(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(self.Caches.TracerCache) do
            self:ClearTracer(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    local screenSize = camera.ViewportSize
    local tracerFrom
    if self.Config.TracerOrigin == 'Bottom Screen' then
        tracerFrom = Vector2.new(screenSize.X / 2, screenSize.Y)
    elseif self.Config.TracerOrigin == 'Cursor' then
        tracerFrom = UserInputService:GetMouseLocation()
    elseif self.Config.TracerOrigin == 'Top Screen' then
        tracerFrom = Vector2.new(screenSize.X / 2, 0)
    end

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            self:ClearTracer(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            self:ClearTracer(player)
            continue
        end

        local targetHead = character:FindFirstChild("Head") or character.HumanoidRootPart
        local distance = (localRoot.Position - targetHead.Position).Magnitude
        if distance > self.Config.ESPDistance then
            self:ClearTracer(player)
            continue
        end

        if self.Config.TeamCheck and LocalPlayer.Team and player.Team == LocalPlayer.Team then
            self:ClearTracer(player)
            continue
        end

        if not self.Caches.TracerCache[player] then
            self.Caches.TracerCache[player] = self:CreateTracer(player)
        end

        local tracer = self.Caches.TracerCache[player]
        local headPos, onScreen = camera:WorldToViewportPoint(targetHead.Position)
        tracer.From = tracerFrom
        tracer.To = Vector2.new(headPos.X, headPos.Y)
        tracer.Visible = onScreen and self.State.TracerEnabled
    end
end

function ZixyESP:UpdateChams()
    if not self.State.ChamsEnabled then
        for player, _ in pairs(self.Caches.ChamsCache) do
            self:ClearChams(player)
        end
        return
    end

    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        for player, _ in pairs(self.Caches.ChamsCache) do
            self:ClearChams(player)
        end
        return
    end

    local localRoot = LocalPlayer.Character.HumanoidRootPart
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') or not player.Character:FindFirstChild('Humanoid') then
            self:ClearChams(player)
            continue
        end

        local character = player.Character
        local humanoid = character.Humanoid
        if humanoid.Health <= 0 then
            self:ClearChams(player)
            continue
        end

        local targetRoot = character.HumanoidRootPart
        local distance = (localRoot.Position - targetRoot.Position).Magnitude
        if distance > self.Config.ESPDistance then
            self:ClearChams(player)
            continue
        end

        if self.Config.TeamCheck and LocalPlayer.Team and player.Team == LocalPlayer.Team then
            self:ClearChams(player)
            continue
        end

        if not self.Caches.ChamsCache[player] then
            self.Caches.ChamsCache[player] = self:CreateChams(player)
        end
    end
end

-- Public methods
function ZixyESP.new()
    local self = setmetatable({}, ZixyESP)
    return self
end

function ZixyESP:InitiateBox(color)
    self.State.BoxEnabled = true
    if color then
        self.Config.BoxColor = color
        for _, esp in pairs(self.Caches.BoxCache) do
            esp.Box.Color = color
        end
    end
end

function ZixyESP:InitiateName(enabled)
    self.State.NameEnabled = enabled or true
end

function ZixyESP:InitiateDistance(enabled)
    self.State.DistanceEnabled = enabled or true
end

function ZixyESP:InitiateSkeleton(color)
    self.State.SkeletonEnabled = true
    if color then
        self.Config.SkeletonColor = color
        for _, skeleton in pairs(self.Caches.SkeletonCache) do
            for _, line in pairs(skeleton) do
                line.Color = color
            end
        end
    end
end

function ZixyESP:InitiateHealthText(enabled)
    self.State.HealthTextEnabled = enabled or true
end

function ZixyESP:InitiateHealthBar(enabled)
    self.State.HealthBarEnabled = enabled or true
end

function ZixyESP:InitiateTracer(color, origin)
    self.State.TracerEnabled = true
    if color then
        self.Config.TracerColor = color
        for _, tracer in pairs(self.Caches.TracerCache) do
            tracer.Color = color
        end
    end
    if origin then
        self.Config.TracerOrigin = origin
    end
end

function ZixyESP:InitiateChams(color)
    self.State.ChamsEnabled = true
    if color then
        self.Config.ChamsColor = color
        for _, chams in pairs(self.Caches.ChamsCache) do
            chams.FillColor = color
        end
    end
end

function ZixyESP:SetDistance(distance)
    self.Config.ESPDistance = distance
end

function ZixyESP:TeamCheck(enabled)
    self.Config.TeamCheck = enabled
end

function ZixyESP:Cleanup()
    for player, _ in pairs(self.Caches.BoxCache) do
        self:ClearBox(player)
    end
    for player, _ in pairs(self.Caches.SkeletonCache) do
        self:ClearSkeleton(player)
    end
    for player, _ in pairs(self.Caches.TracerCache) do
        self:ClearTracer(player)
    end
    for player, _ in pairs(self.Caches.ChamsCache) do
        self:ClearChams(player)
    end
end

function ZixyESP:Destroy()
    self:Cleanup()
    if cleanupConnection then
        cleanupConnection:Disconnect()
    end
    if updateConnection then
        updateConnection:Disconnect()
    end
    self.State.BoxEnabled = false
    self.State.NameEnabled = false
    self.State.DistanceEnabled = false
    self.State.SkeletonEnabled = false
    self.State.HealthTextEnabled = false
    self.State.HealthBarEnabled = false
    self.State.TracerEnabled = false
    self.State.ChamsEnabled = false
end

-- Initialize cleanup and update loops
function ZixyESP:Initialize()
    -- Player event handlers
    Players.PlayerRemoving:Connect(function(player)
        SafeExecute(function()
            self:ClearBox(player)
            self:ClearSkeleton(player)
            self:ClearTracer(player)
            self:ClearChams(player)
        end)
    end)

    Players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function(character)
            character.AncestryChanged:Connect(function()
                if not character:IsDescendantOf(Workspace) then
                    SafeExecute(function()
                        self:ClearBox(player)
                        self:ClearSkeleton(player)
                        self:ClearTracer(player)
                        self:ClearChams(player)
                    end)
                end
            end)
            local humanoid = character:FindFirstChild('Humanoid')
            if humanoid then
                humanoid.Died:Connect(function()
                    SafeExecute(function()
                        self:ClearBox(player)
                        self:ClearSkeleton(player)
                        self:ClearTracer(player)
                        self:ClearChams(player)
                    end)
                end)
            end
        end)
    end)

    -- Periodic cleanup
    cleanupConnection = RunService.Heartbeat:Connect(function()
        if os.clock() % cleanupInterval < 0.1 then
            SafeExecute(function()
                self:Cleanup()
            end)
        end
    end)

    -- Update loop
    updateConnection = RunService.RenderStepped:Connect(function()
        SafeExecute(function() self:UpdateBox() end)
        SafeExecute(function() self:UpdateSkeleton() end)
        SafeExecute(function() self:UpdateTracer() end)
        SafeExecute(function() self:UpdateChams() end)
    end)
end

return ZixyESP
